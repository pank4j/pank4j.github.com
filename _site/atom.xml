<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

 <title>CodePwn</title>
 <link href="http://www.codepwn.com/atom.xml" rel="self"/>
 <link href="http://www.codepwn.com/"/>
 <updated>2014-09-13T03:47:19+08:00</updated>
 <id>http://www.codepwn.com</id>
 <author>
   <name>Pankaj Kohli</name>
   <email></email>
 </author>

 
 <entry>
   <title>AppMinder jailbreak detection analysis</title>
   <link href="http://www.codepwn.com/posts/appminder-jailbreak-detection-analysis"/>
   <updated>2013-12-28T20:38:07+08:00</updated>
   <id>http://www.codepwn.com/posts/appminder-jailbreak-detection-analysis</id>
   <content type="html">&lt;p&gt;Neso Lab&amp;#39;s &lt;a href=&quot;http://appminder.nesolabs.de/&quot;&gt;AppMinder&lt;/a&gt; project is another attempt at providing jailbreak detection for enterprise iOS applications (and perhaps AppStore apps). It provides three variants of jailbreak detections codes, each with an increasing level of self integrity checks and code obfuscation, and optionally including anti-debugging checks. It generates a piece of code with a function containing inline assembly code which can be inserted into the app&amp;#39;s source code and called where jailbreak detection needs to be implemented. The generated code is metamorphic with a random function name. Metamorphism is achieved by a combination of register interchanges, instruction reordering, inserting dead code such as unused &lt;code&gt;push&lt;/code&gt;, &lt;code&gt;pop&lt;/code&gt; and &lt;code&gt;cmp&lt;/code&gt; instructions.&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/31f55ba86926d6de3ded.js&quot;&gt; &lt;/script&gt;

&lt;p&gt;The code can be made a little more readable using &lt;code&gt;cat jbdetect.c | tr &amp;#39;;&amp;#39; &amp;#39;\n&amp;#39;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The code makes use of &lt;code&gt;svc 0x80&lt;/code&gt; instruction throughout to invoke system calls. &lt;code&gt;svc 0x80&lt;/code&gt; is the ARM counterpart of Intel&amp;#39;s &lt;code&gt;int 0x80&lt;/code&gt; instruction, used to invoke system calls. In iOS, which is a derivative of Darwin, the system call number is passed in r12 and the arguments in r0-r3. The return value is optionally returned in r0. &lt;code&gt;svc&lt;/code&gt; also goes by the name of &lt;code&gt;swi&lt;/code&gt; or &lt;em&gt;software interrupt&lt;/em&gt;.&lt;/p&gt;

&lt;h2&gt;Debugger detection&lt;/h2&gt;

&lt;p&gt;Process tracing utilities and debuggers make use of &lt;code&gt;ptrace&lt;/code&gt; system call to trace a running process. If the &amp;#39;Anti-debugging option&amp;#39; was selected, the code tries to detect and deny any debugging attempts. It does this by invoking &lt;code&gt;ptrace&lt;/code&gt; (system call 26) on the current process with an argument of 31, i.e. &lt;code&gt;PTRACE_DENY_ATTACH&lt;/code&gt;. Quoting from the man page:&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/dcdd20621395c8fd396b.js&quot;&gt; &lt;/script&gt;

&lt;p&gt;The process is killed if a debugger is detected. Additionally, debuggers are denied to trace the process in any future requests. gdb shows a &amp;quot;Operation not permitted&amp;quot; message if it tries to attach to a process which has called &lt;code&gt;ptrace&lt;/code&gt; with &lt;code&gt;PT_DENY_ATTACH&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;A complete list of system calls can be found in &lt;a href=&quot;http://www.opensource.apple.com/source/xnu/xnu-1228.5.20/bsd/sys/syscall.h&quot;&gt;sys/syscall.h&lt;/a&gt;.&lt;/p&gt;

&lt;h2&gt;Jailbreak Detection&lt;/h2&gt;

&lt;p&gt;The code detects jailbreaks using &lt;code&gt;fork&lt;/code&gt;. On non-jailbroken iOS, the sandbox restricts the use of &lt;code&gt;fork&lt;/code&gt;. Calling &lt;code&gt;fork&lt;/code&gt; fails with a return value of 1. However, on a jailbroken iOS, &lt;code&gt;fork&lt;/code&gt; succeeds and spawns a new process. The code terminates the process using &lt;code&gt;exit(1)&lt;/code&gt; if &lt;code&gt;fork&lt;/code&gt; does not return 1.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;The code does not do anything new, and does not even conceal its presence. It can be easily identified in memory by simply looking for &lt;code&gt;svc 0x80&lt;/code&gt; instructions, which assemble to &lt;code&gt;80 00 00 EF&lt;/code&gt;. Given the fact that jailbreak detection is inherently self defeating, it becomes trivial to bypass the above checks.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Dirty Harry: Hacking for free drinks in Singapore</title>
   <link href="http://www.codepwn.com/posts/dirty-harry-hacking-for-free-drinks-in-singapore"/>
   <updated>2013-11-04T00:38:07+08:00</updated>
   <id>http://www.codepwn.com/posts/dirty-harry-hacking-for-free-drinks-in-singapore</id>
   <content type="html">&lt;p&gt;&lt;a href=&quot;http://harrys.com.sg/&quot;&gt;Harry&amp;#39;s bar&lt;/a&gt; is one of the most popular bar chains in Singapore. It has an iOS app &amp;quot;Appy Hour&amp;quot; that lets users spin the Harry&amp;#39;s &amp;quot;wheel of fortune&amp;quot; to win free drinks. The way it works is that a user would visit one of their strategically located bars and check in using the app. He would then spin the wheel, and if he is lucky, he would win a free drink. A time limit is imposed so that a user can spin the wheel only once in 24 hours while signed in a particular bar.&lt;/p&gt;

&lt;p&gt;Now there may not be any such thing as a free lunch, but there are free drinks! Let&amp;#39;s see how.&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&quot;/public/win240x360.png&quot; /&gt;&lt;/center&gt;
&lt;p&gt;&lt;/p&gt;&lt;/p&gt;

&lt;h2&gt;The &amp;#39;luck factor&amp;#39;&lt;/h2&gt;

&lt;p&gt;The app communicates with &lt;code&gt;www.exhost.se&lt;/code&gt; over HTTP. When started, the first thing the app does is to define the &amp;quot;luck factor&amp;quot; of the user, by downloading an XML file containing probabilities of various prizes. The probabilities are set in way such that 52% of the time a spin would yield &amp;#39;Better Luck Next Time&amp;#39;.&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/1fd3fb43e9c7ed639b52.js&quot;&gt; &lt;/script&gt;

&lt;h2&gt;Time Restriction&lt;/h2&gt;

&lt;p&gt;Once the user has checked in the bar, the app checks if the user has already tried his luck in the past 24 hours in the same bar. It does so by sending a request with the iPhone&amp;#39;s UDID, a timestamp and the bar&amp;#39;s id. The response simply consists of &lt;code&gt;true&lt;/code&gt; if the user is allowed to spin the wheel, or &lt;code&gt;false&lt;/code&gt; otherwise.&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/7af63a6d30a1ac868c65.js&quot;&gt; &lt;/script&gt;

&lt;h2&gt;Getting past everything&lt;/h2&gt;

&lt;p&gt;Well, the simplest way to get past everything would be to make the app communicate with another server instead of &lt;code&gt;www.exhost.se&lt;/code&gt;. First we will crawl &lt;code&gt;www.exhost.se&lt;/code&gt; to get all the required files. The link &lt;code&gt;http://www.exhost.se/harrys_1_1_beta/&lt;/code&gt; does not contain a default &lt;code&gt;index.html&lt;/code&gt; or similar file, which makes crawling possible.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/public/wget-harrys.png&quot; alt=&quot;wget&quot;&gt;
&lt;img src=&quot;/public/strings-harrys.png&quot; alt=&quot;strings&quot;&gt;&lt;/p&gt;

&lt;p&gt;Once we have the crawled files, we can edit the &lt;code&gt;venues.xml&lt;/code&gt; file to change the probabilities. We can even change the drinks! ;-) Also, the file &lt;code&gt;fetchdata.php&lt;/code&gt; should contain &lt;code&gt;true&lt;/code&gt; for us to spin any number of times. Now these files can be hosted on a different server and these URLs can be changed in the app mach-o binary. Changing only the above two URLs is sufficient to make it work without any restrictions. The strings utility comes handy when trying to find out the location of these strings in the binary. These strings can now be edited using a hex editor. &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/public/strings.png&quot; alt=&quot;Strings as seen in the disassembler after modification&quot;&gt;&lt;/p&gt;

&lt;p&gt;Once edited, we can run the app any number of times while signed in the same bar, and win a drink on every spin!&lt;/p&gt;

&lt;p&gt;Cheers!&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Assembling from scratch: Encoding BLX instruction in ARM / THUMB</title>
   <link href="http://www.codepwn.com/posts/assembling-from-scratch-encoding-blx-instruction-in-arm-thumb"/>
   <updated>2013-10-19T13:23:25+08:00</updated>
   <id>http://www.codepwn.com/posts/assembling-from-scratch-encoding-blx-instruction-in-arm-thumb</id>
   <content type="html">&lt;p&gt;&lt;center&gt;&lt;img src=&quot;/public/blx.png&quot; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;If you have been working on x86 disassembly and moving on to ARM disassembly, one of the subtle differences you may notice is the lack of byte aligned opcodes in ARM (or THUMB) instruction set. Being based on RISC, ARM architecture provides fewer instructions as compared to x86. The need to implement an instruction set having functionally similar instructions as their x86 counterparts, only using fewer (and perhaps smaller) instructions gave rise to the instructions where opcodes are not dictated by bytes but by bits.&lt;/p&gt;

&lt;p&gt;One of such intriguing instructions in ARM is BLX. BLX instruction performs a PC relative unconditional branch, and optionally changes mode to ARM or THUMB depending on the target address. It encodes to a 32-bit word under THUMB mode 2. It&amp;#39;s encoding varies depending upon the relative offset between the instruction and the target address. For e.g. the instruction at 0x2EA6 in the disassembly above encodes to &lt;code&gt;D8 F0 08 E8&lt;/code&gt; while another BLX instruction at 0x30C4 encodes to &lt;code&gt;8E F3 C4 E9&lt;/code&gt;. The encoded instruction itself is divided into two 16-bit halves, each of which is shown in little-endian. The actual encodings are therefore F0 D8 E8 08 and F3 8E E9 C4. The encoding is explained in the THUMB instruction set (available &lt;a href=&quot;https://ece.uwaterloo.ca/%7Eece222/ARM/ARM7-TDMI-manual-pt3.pdf&quot;&gt;here&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;
&lt;style type=&quot;text/css&quot;&gt;
.pic {
    display: inline-block;
    margin-left: auto;
    margin-right: 10%;
    /*height: 30px;*/
}

#images {
    text-align:center;
}
&lt;/style&gt;
&lt;div id=&quot;images&quot;&gt;
&lt;img class=&quot;pic&quot; src=&quot;/public/blxasm1.png&quot; /&gt;&lt;img class=&quot;pic&quot; src=&quot;/public/blxasm2.png&quot; /&gt;
&lt;/div&gt;
&lt;/p&gt;

&lt;h2&gt;Calculating the offset&lt;/h2&gt;

&lt;p&gt;The instruction at 0x2EA6 branches to &lt;code&gt;_obj_msgSend&lt;/code&gt;, which is at 0xDAEB8. The offset for encoding is calculated from the current value of PC which is 4 bytes ahead due to pipeline, i.e. 0x2EAA. When the target of branch is 32-bit ARM code, the value used is align(PC, 4), which is PC rounded down to align it to 4 bytes, i.e. PC &amp;amp; 0xFFFFFFFC (0x2EA8 in this case). The offset is therefore, 0xDAEB8 - 0x2EA8 = 0xD8010.&lt;br/&gt;&lt;/p&gt;

&lt;h2&gt;Encoding the instruction&lt;/h2&gt;

&lt;p&gt;The offset is then used to encode the instruction as follows:&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/140b298c1038bc17c138.js&quot;&gt; &lt;/script&gt;

&lt;p&gt;which explains the encoding seen in the disassembler &lt;code&gt;(D8 F0 08 E8)&lt;/code&gt;. :-)&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Exploiting File Uploads for Fun and Profit</title>
   <link href="http://www.codepwn.com/posts/exploiting-file-uploads-for-fun-and-profit"/>
   <updated>2013-06-29T16:57:50+08:00</updated>
   <id>http://www.codepwn.com/posts/exploiting-file-uploads-for-fun-and-profit</id>
   <content type="html">&lt;p&gt;So I have been working on web application security for past some time. I also happened to write an article titled &amp;quot;Exploiting File Uploads for Fun and Profit&amp;quot; for &lt;a href=&quot;http://hakin9.org/learn-how-to-perform-advanced-web-attacks-and-exploitation-with-more-than-70-pages-of-hakin9-tutorials/&quot;&gt;Hakin9&lt;/a&gt; magazine , which has been published recently. The article explains the various restrictions that are often imposed by web applications on the file being uploaded and how to get around these restrictions. Credit for the techniques described in the article goes to their respective authors.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/public/ExploitingFileUploadsForFunAndProfit-1024x548.png&quot; alt=&quot;Exploiting File Uploads For Fun And Profit&quot;&gt;&lt;/p&gt;

&lt;p&gt;You can download the complete article &lt;a href=&quot;/public/ExploitingFileUploadsForFunAndProfit.pdf&quot;&gt;here&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>httpdx 1.4 GET Request Remote Buffer Overflow Exploit (0day)</title>
   <link href="http://www.codepwn.com/posts/httpdx-1-4-get-request-remote-buffer-overflow-exploit-0day"/>
   <updated>2009-09-04T08:38:36+08:00</updated>
   <id>http://www.codepwn.com/posts/httpdx-1-4-get-request-remote-buffer-overflow-exploit-0day</id>
   <content type="html">&lt;p&gt;httpdx is vulnerable to a stack-based buffer overflow, caused by improper bounds checking by the &lt;code&gt;h_handlepeer()&lt;/code&gt; function. By sending an overly long HTTP GET request, a remote attacker could overflow a buffer and execute arbitrary code on the system or cause the application to crash.&lt;/p&gt;

&lt;p&gt;This exploit is also available as a metasploit module &lt;a href=&quot;http://www.metasploit.com/modules/exploit/windows/http/httpdx_handlepeer&quot;&gt;here&lt;/a&gt;. Thanks to Trancer for porting it to Metasploit.&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/3a5e993809bce4fe36eb.js&quot;&gt; &lt;/script&gt;
</content>
 </entry>
 
 <entry>
   <title>HTMLDOC 'html' File Handling Remote Stack Buffer Overflow Exploit (Linux)</title>
   <link href="http://www.codepwn.com/posts/htmldoc-html-file-handling-remote-stack-buffer-overflow-exploit-linux"/>
   <updated>2009-08-20T08:34:14+08:00</updated>
   <id>http://www.codepwn.com/posts/htmldoc-html-file-handling-remote-stack-buffer-overflow-exploit-linux</id>
   <content type="html">&lt;p&gt;The vulnerability exists in HTMLDOC version 1.8.27 and earlier due to an unsafe call to &lt;code&gt;sscanf()&lt;/code&gt; in the &lt;code&gt;set_page_size()&lt;/code&gt; function in &lt;code&gt;htmldoc/util.cxx&lt;/code&gt;. This can be exploited to cause a stack-based buffer overflow when an HTML document containing e.g. a specially crafted &amp;quot;MEDIA SIZE&amp;quot; comment is being processed.&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/95e360d4694d7e92e98e.js&quot;&gt; &lt;/script&gt;
</content>
 </entry>
 
 <entry>
   <title>VLC Media Player 'smb://' URI Handling Remote Buffer Overflow Vulnerability Exploit</title>
   <link href="http://www.codepwn.com/posts/vlc-media-player-smb-uri-handling-remote-buffer-overflow-vulnerability-exploit"/>
   <updated>2009-08-07T08:15:46+08:00</updated>
   <id>http://www.codepwn.com/posts/vlc-media-player-smb-uri-handling-remote-buffer-overflow-vulnerability-exploit</id>
   <content type="html">&lt;p&gt;A stack-based buffer overflow exists in the &lt;code&gt;Win32AddConnection&lt;/code&gt; function in &lt;code&gt;modules/access/smb.c&lt;/code&gt; in VideoLAN VLC media player 0.9.9, when running on Microsoft Windows, that allows remote attackers to execute arbitrary code via a long smb URI in a playlist file.&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/aa6c6809f7c124b19add.js&quot;&gt; &lt;/script&gt;
</content>
 </entry>
 
 <entry>
   <title>FormatShield: A tool to defend against format string attacks</title>
   <link href="http://www.codepwn.com/posts/formatshield"/>
   <updated>2009-06-30T23:14:29+08:00</updated>
   <id>http://www.codepwn.com/posts/formatshield</id>
   <content type="html">&lt;p&gt;FormatShield is a library that intercepts call to vulnerable functions and uses binary rewriting to defend against format string attacks. It identifies the vulnerable call sites in a running process and dumps the corresponding context information in the ELF binary of the process. Attacks are detected when format specifiers are found at these contexts of the vulnerable call sites.&lt;/p&gt;

&lt;p&gt;FormatShield provides wrappers for the following libc functions:&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/bb3a6193cadaabaca33a.js&quot;&gt; &lt;/script&gt;

&lt;p&gt;On detecting an attack, the victim process is killed and a log is written to syslog. More details about the inner working of FormatShield are available in the &lt;a href=&quot;/public/formatshield-acisp08.pdf&quot;&gt;research paper&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/pank4j/formatshield&quot;&gt;Formatshield source&lt;/a&gt; is licensed as GNU GPL v3 and is archived on github. It is available only for testing/research, please use it at your own risk.&lt;/p&gt;
</content>
 </entry>
 

</feed>
